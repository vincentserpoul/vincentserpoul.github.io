<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blockchain on VS tech corner</title>
    <link>https://vincentserpoul.github.io/tags/blockchain/index.xml</link>
    <description>Recent content in Blockchain on VS tech corner</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://vincentserpoul.github.io/tags/blockchain/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ethereum react dapps</title>
      <link>https://vincentserpoul.github.io/post/ethereum-react-dapps/</link>
      <pubDate>Thu, 27 Oct 2016 13:34:00 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-react-dapps/</guid>
      <description>

&lt;p&gt;I finished my first dapp with (react-boilerplate)[&lt;a href=&#34;https://github.com/mxstbr/&#34;&gt;https://github.com/mxstbr/&lt;/a&gt;] this week and here are the few things I learnt.
I won&amp;rsquo;t get into the redux, redux-saga details, I let you play with the amazing boilerplate.&lt;/p&gt;

&lt;h2 id=&#34;interacting-with-constant-functions&#34;&gt;Interacting with constant functions&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s use the typical balanceOf function of the EIP20 contracts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are the sagas (redux-sagas) I used to interact:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { take, call, put, cancel, select, fork } from &#39;redux-saga/effects&#39;;
import {
  BALANCE_OF_GET,
} from &#39;./constants&#39;;
import { LOCATION_CHANGE } from &#39;react-router-redux&#39;;

import {
  balanceOfSuccess,
  balanceOfFailure,
} from &#39;./actions&#39;;

import { selectEthConnectWeb3Connection } from &#39;containers/EthConnect/selectors&#39;;

import HumanStandardToken from &#39;contracts/HumanStandardToken.sol.js&#39;;

function* balanceOfGet(ethAddress) {
  const web3Connection = yield select(selectEthConnectWeb3Connection());

  HumanStandardToken.setProvider(web3Connection.currentProvider);
  const token = HumanStandardToken.deployed();

  const balancePromise = yield call(token.balanceOf, ethAddress);

  // We return an object in a specific format, see utils/request.js for more information
  if (balancePromise.err === undefined || balancePromise.err === null) {
    yield put(balanceOfSuccess(ethAddress, balancePromise.valueOf()));
  } else {
    console.log(balancePromise.err.response); // eslint-disable-line no-console
    yield put(balanceOfFailure(ethAddress, balancePromise.err.response));
  }
}

/**
 * Watches for BALANCE_OF_GET action and calls handler
 */
export function* balanceOfWatcher() {
  while (true) { // eslint-disable-line no-constant-condition
    const { ethAddress } = yield take(BALANCE_OF_GET);
    // use fork and not call to be sure to fork all
    yield fork(balanceOfGet, ethAddress);
  }
}


/**
 * Root saga manages watcher lifecycle
 */
export function* balanceOfSaga() {
  // Fork watcher so we can continue execution
  const watcher = yield fork(balanceOfWatcher);

  // Suspend execution until location changes
  yield take(LOCATION_CHANGE);
  yield cancel(watcher);
}

// All sagas to be loaded
export default [
  balanceOfSaga,
];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, simply implement the right reducers, actions and you are done! you can easily get the balance in your UI.&lt;/p&gt;

&lt;h2 id=&#34;interacting-with-functions-that-needs-transactions&#34;&gt;Interacting with functions that needs transactions&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s use the same EIP20 contract again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { take, call, put, select, cancel, fork } from &#39;redux-saga/effects&#39;;
import {
  GIVEMETOKEN_LAUNCH,
} from &#39;./constants&#39;;
import { LOCATION_CHANGE } from &#39;react-router-redux&#39;;

import {
  givemetokensSuccess,
  givemetokensFailure,
} from &#39;./actions&#39;;

import {
  balanceOfGet,
} from &#39;containers/Token/actions&#39;;

import { selectEthConnectWeb3Connection } from &#39;containers/EthConnect/selectors&#39;;
// import { selectRianEthAddress } from &#39;./selectors&#39;;

import HumanStandardToken from &#39;contracts/HumanStandardToken.sol.js&#39;;

function* givemetokens(ethAddress) {
  const web3Connection = yield select(selectEthConnectWeb3Connection());
  HumanStandardToken.setProvider(web3Connection.currentProvider);
  const tokens = HumanStandardToken.deployed();

  const tokensOwner = yield call(tokens.getOwner.call);

  try {
    yield call(tokens.approve, ethAddress, 100, { from: tokensOwner, gas: 200000 });
  } catch (e) {
    console.log(e); // eslint-disable-line no-console
    yield put(givemetokensFailure(ethAddress));
    return;
  }

  const approvedAmt = yield call(tokens.allowance.call, tokensOwner, ethAddress);
  console.log(`approved amount: ${approvedAmt}`);

  try {
    yield call(tokens.transferFrom, tokensOwner, ethAddress, 100, { from: ethAddress, gas: 200000 });
  } catch (e) {
    console.log(e); // eslint-disable-line no-console
    yield put(givemetokensFailure(ethAddress));
  }

  yield put(givemetokensSuccess(ethAddress, true));
  yield put(balanceOfGet(ethAddress));
}

/**
 * Watches for SIMPLEINSURANCE_givemetokens_LAUNCH action and calls handler
 */
export function* givemetokensWatcher() {
  while (true) { // eslint-disable-line no-constant-condition
    const { ethAddress } = yield take(GIVEMETOKEN_LAUNCH);
    yield call(givemetokens, ethAddress);
  }
}


/**
 * Root saga manages watcher lifecycle
 */
export function* givemetokensSaga() {
  // Fork watcher so we can continue execution
  const watcher = yield fork(givemetokensWatcher);

  // Suspend execution until location changes
  yield take(LOCATION_CHANGE);
  yield cancel(watcher);
}

// All sagas to be loaded
export default [
  givemetokensSaga,
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At that point, you only know that the transaction has gone through, you don&amp;rsquo;t really know what happened. That&amp;rsquo;s when you need to listen to the event of your contracts.&lt;/p&gt;

&lt;h2 id=&#34;listening-to-events&#34;&gt;Listening to events&lt;/h2&gt;

&lt;p&gt;Same example as above, we will listen to the Approval event.
We need to create a eventChannel, as the event is coming from &lt;em&gt;outside&lt;/em&gt; this time, it won&amp;rsquo;t be generated by our own UI.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const ethEvent = () =&amp;gt; eventChannel((emitter) =&amp;gt; {
  const tokensApproval = tokens.Approval({ fromBlock: &#39;latest&#39; });
  tokensApproval.watch((error, results) =&amp;gt; {
    const eventType = &#39;approve&#39;;
    const eventTime = new Date().toISOString();
    const eventEthAddress = results.args._owner;
    let eventDescription;
    if (error) {
      console.log(`Approval error ${error}`); // eslint-disable-line no-console
      eventDescription = `ERROR - ${results.args._owner.substring(0,6)} allowed ${results.args._spender.substring(0,6)} to spend ${results.args._value}Ʉ on his behalf`;
    } else {
      eventDescription = `${results.args._owner.substring(0,6)} allowed ${results.args._spender.substring(0,6)} to spend ${results.args._value}Ʉ on his behalf`;
    }

    emitter({ eventEthAddress, eventType, eventTime, eventDescription });
  });

  return () =&amp;gt; {
    tokensApproval.stopWatching();
  };
});

function* handleEthEvent(event) {
  switch (event.eventType) {
    case &#39;approve&#39;:
      yield put(ethEventListenerReceiveAction(event.eventEthAddress, event.eventType, event.eventTime, event.eventDescription));
      break;
    default:
      console.log(event); // eslint-disable-line no-console
  }
}

export function* ethEventListenerSaga() {
  yield put(ethEventListenerCreateAction());

  const chan = yield call(ethEvent);
  try {
    while (true) {
      const event = yield take(chan);
      yield call(handleEthEvent, event);
    }
  } finally {
    if (yield cancelled()) {
      chan.close();
      console.log(&#39;listening cancelled&#39;);
    }
  }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here you go! You can now listen to the stream of events.&lt;/p&gt;

&lt;h2 id=&#34;getting-a-list-of-events&#34;&gt;Getting a list of events&lt;/h2&gt;

&lt;p&gt;In Ethereum, you can get the list of past events, it can kind of act like a kind of storage for the history of your contracts (I won&amp;rsquo;t go into details for this, but some node might not keep the whole history).&lt;/p&gt;

&lt;p&gt;How to get the history of events on the contract?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { take, call, put, cancel, fork } from &#39;redux-saga/effects&#39;;
import {
  APPROVAL_HISTORY_GET,
} from &#39;./constants&#39;;
import { LOCATION_CHANGE } from &#39;react-router-redux&#39;;
import { web3Connect } from &#39;utils/web3.js&#39;;
import {
  receiveApprovalHistory,
} from &#39;./actions&#39;;
import {
  balanceOfGet,
} from &#39;containers/Token/actions&#39;;
import HumanStandardToken from &#39;contracts/HumanStandardToken.sol.js&#39;;

function* getApprovalHistory(ethAddress) {
  const web3Connection = web3Connect();

  HumanStandardToken.setProvider(web3Connection.currentProvider);
  const tokens = HumanStandardToken.deployed();

  const approvalHistory = [];
  // Getting the list of events from block 0 to latest block, with a filter on _owner as it is an indexed field
  const tokensApproval = tokens.Approval({ _owner: ethAddress }, { fromBlock: &#39;0&#39;, toBlock: &#39;latest&#39; });

  const getApprovalLogPromise = yield call(eventGetPromisified, tokensApproval);

  if (getApprovalLogPromise.err === null || getApprovalLogPromise.err === undefined) {
    for (const results of getApprovalLogPromise) {
      approvalHistory.push({
        trigger: results.args._trigger,
        measurement: results.args._measurement.valueOf(),
        premium: results.args._amount.valueOf(),
        refundedAmount: results.args._refundAmount.valueOf(),
        settled: results.args._timeEnded.valueOf(),
        refunded: results.args._due.valueOf(),
      });
    }
  } else {
    console.log(getApprovalLogPromise.err);
  }

  yield put(receiveApprovalHistory(ethAddress, approvalHistory));
}

// Event promisifier to turn the nasty web3 callback to a promise ES6 form
const eventGetPromisified = (event) =&amp;gt; new Promise((resolve, reject) =&amp;gt; {
  event.get((error, logs) =&amp;gt; {
    if (error) {
      reject(error);
    } else {
      resolve(logs);
    }
  });
});

/**
 * Watches for APPROVAL_HISTORY_GET action and calls handler
 */
export function* getApprovalHistoryWatcher() {
  while (true) { // eslint-disable-line no-constant-condition
    const { ethAddress } = yield take(APPROVAL_HISTORY_GET);
    yield fork(getApprovalHistory, ethAddress);
  }
}

/**
 * Root saga manages watcher lifecycle
 */
export function* approvalHistorySaga() {
  // Fork watcher so we can continue execution
  const getApprovalHistoryW = yield fork(getApprovalHistoryWatcher);

  // Suspend execution until location changes
  yield take(LOCATION_CHANGE);
  yield cancel(getApprovalHistoryW);
}

// All sagas to be loaded
export default [
  approvalHistorySaga,
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voila!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ethereum contracts and Golang</title>
      <link>https://vincentserpoul.github.io/post/binding-ethereum-golang/</link>
      <pubDate>Mon, 10 Oct 2016 12:54:00 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/binding-ethereum-golang/</guid>
      <description>

&lt;h2 id=&#34;the-contract&#34;&gt;The contract&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;contract Trigger {
  function () {
      throw;
  }

  address owner;

  function Trigger() {
      owner = msg.sender;
  }

  event TriggerEvt(address _sender, uint _trigger);

  function trigger(uint _trigger) {
      TriggerEvt(msg.sender, _trigger);
  }

  function getOwner() constant returns (address) {
    return owner;
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very simple contract that we will take as an example.&lt;/p&gt;

&lt;h2 id=&#34;getting-the-right-tools-for-binding&#34;&gt;Getting the right tools for binding&lt;/h2&gt;

&lt;p&gt;A good starting point is this &lt;a href=&#34;https://github.com/ethereum/go-ethereum/wiki/Native-DApps:-Go-bindings-to-Ethereum-contracts&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You will need to follow the install procedure of &lt;a href=&#34;https://github.com/ethereum/go-ethereum&#34;&gt;go-ethereum&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once done, you should have the abigen executable available on your command line.&lt;/p&gt;

&lt;h2 id=&#34;automatically-generating-the-go-file&#34;&gt;Automatically generating the go file&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;abigen --sol contracts/Trigger.sol --pkg main --out trigger.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything is fine, you should now have a file named trigger.go&lt;/p&gt;

&lt;h2 id=&#34;using-the-generated-file-from-main&#34;&gt;Using the generated file from main&lt;/h2&gt;

&lt;p&gt;You first need to have a node running (parity, geth, testrpc&amp;hellip;). We will assume it&amp;rsquo;s listening on port 9012.
You then need to deploy your contract and write down the deployment address (you can use truffle or simple deploy your contract manually or use the following code with a working key pair).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;log&amp;quot;
  &amp;quot;strings&amp;quot;
  &amp;quot;time&amp;quot;

  &amp;quot;github.com/ethereum/go-ethereum/accounts/abi/bind&amp;quot;
  &amp;quot;github.com/ethereum/go-ethereum/accounts/abi/bind/backends&amp;quot;
  &amp;quot;github.com/ethereum/go-ethereum/rpc&amp;quot;
)

func main() {
  // Create an IPC based RPC connection to a remote node
  conn, err := rpc.NewHTTPClient(&amp;quot;http://localhost:9012&amp;quot;)
  if err != nil {
    log.Fatalf(&amp;quot;Failed to connect to the Ethereum client: %v&amp;quot;, err)
  }

  // IF YOU WANT TO DEPLOY YOURSELF
  // this is the json found in your geth chain/keystore folder
  key := `{&amp;quot;address&amp;quot;:&amp;quot;f2759b4a699dae4fdc3383a0d7a92cfc246315cd&amp;quot;,&amp;quot;crypto&amp;quot;:{&amp;quot;cipher&amp;quot;:&amp;quot;aes-128-ctr&amp;quot;,&amp;quot;ciphertext&amp;quot;:&amp;quot;a96fe235356c7ebe6520d2fa1dcc0fd67199cb490fb18c39ffabbb6880a6b3d6&amp;quot;,&amp;quot;cipherparams&amp;quot;:{&amp;quot;iv&amp;quot;:&amp;quot;47182104a4811f8da09c0bafc3743e2a&amp;quot;},&amp;quot;kdf&amp;quot;:&amp;quot;scrypt&amp;quot;,&amp;quot;kdfparams&amp;quot;:{&amp;quot;dklen&amp;quot;:32,&amp;quot;n&amp;quot;:262144,&amp;quot;p&amp;quot;:1,&amp;quot;r&amp;quot;:8,&amp;quot;salt&amp;quot;:&amp;quot;81c82f97edb0ee1036e63d1de57b7851271273971803e60a5cbb011e85baa251&amp;quot;},&amp;quot;mac&amp;quot;:&amp;quot;09f107c9af8efcb932354d939beb7b2c0cebcfd70362d68905de554304a7cfff&amp;quot;},&amp;quot;id&amp;quot;:&amp;quot;eb7ed04f-e996-4bda-893b-28dc6ac24626&amp;quot;,&amp;quot;version&amp;quot;:3}`
  auth, err := bind.NewTransactor(strings.NewReader(key), &amp;quot;1234567890&amp;quot;)
  if err != nil {
    log.Fatalf(&amp;quot;Failed to create authorized transactor: %v&amp;quot;, err)
  }
  // Deploy a new awesome contract for the binding demo
  triggerAddr, _, trigger, err := DeployTrigger(auth, backends.NewRPCBackend(conn))
  if err != nil {
    log.Fatalf(&amp;quot;Failed to deploy new trigger contract: %v&amp;quot;, err)
  }
  // Don&#39;t even wait, check its presence in the local pending state
  time.Sleep(5 * time.Second) // Allow it to be processed by the local node :P
  // END IF YOU WANT TO DEPLOY YOURSELF

  // IF YOU HAVE ALREADY DEPLOYED IT
  // deployedTriggerAddr := &amp;quot;0xe2359b4a699dae4fdc3383a0d7a92cfc246315ce&amp;quot;
  deployedTriggerAddr := triggerAddr
  trigger, err = NewTrigger(deployedTriggerAddr, backends.NewRPCBackend(conn))
  if err != nil {
    log.Fatalf(&amp;quot;Failed to instantiate a trigger contract: %v&amp;quot;, err)
  }
  // END IF YOU HAVE ALREADY DEPLOYED IT

  owner, err := trigger.GetOwner(nil)
  if err != nil {
    log.Fatalf(&amp;quot;Failed to retrieve token name: %v&amp;quot;, err)
  }
  fmt.Printf(&amp;quot;owner address: 0x%x\n&amp;quot;, owner)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then, just run it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go run *.go
owner address: 0xf2759b4a699dae4fdc3383a0d7a92cfc246315cd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voila!&lt;/p&gt;

&lt;h2 id=&#34;existing-issues&#34;&gt;Existing issues&lt;/h2&gt;

&lt;p&gt;We have still not talked about listening to events.
There are also still issues as soon as the contract imports other contracts, I will finish the writing once these are done.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Blockchain week in Shanghai!</title>
      <link>https://vincentserpoul.github.io/post/ethereum-solidity/</link>
      <pubDate>Fri, 16 Sep 2016 13:44:00 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-solidity/</guid>
      <description>&lt;p&gt;I participated to the devcon2 and blockchain summit last week.
 &lt;a href=&#34;https://medium.com/innovateforward/blockchain-week-in-shanghai-8b38454eaeeb#.d4cnfj72z&#34;&gt;Here&lt;/a&gt; is my summary!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interacting with an Ethereum smart contract</title>
      <link>https://vincentserpoul.github.io/post/ethereum-interacting-with-contracts/</link>
      <pubDate>Wed, 03 Aug 2016 20:00:00 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-interacting-with-contracts/</guid>
      <description>

&lt;h2 id=&#34;check-the-address-of-the-current-deployed-contract&#34;&gt;Check the address of the current deployed contract&lt;/h2&gt;

&lt;p&gt;Remember when you mined your contract, it told your its address.
Now, reuse it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eth.getCode(&amp;quot;0x5f3425ccedeae0eb36521c4cf93ec6544dbad9bd&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-the-contract-with-a-simple-interaction&#34;&gt;Test the contract with a simple interaction&lt;/h2&gt;

&lt;p&gt;get the latest web3-light.min.js js from &lt;a href=&#34;https://github.com/ethereum/web3.js/releases&#34;&gt;https://github.com/ethereum/web3.js/releases&lt;/a&gt; and simply copy the dist/web3-light.min.js into the same folder as the following HTML file.&lt;/p&gt;

&lt;p&gt;then, use this html to interact with your contract on the local node:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/bignumber.js/2.4.0/bignumber.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./web3-light.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    var Web3 = require(&#39;web3&#39;);
    var web3 = new Web3();
    web3.setProvider(new web3.providers.HttpProvider(&#39;http://localhost:9012&#39;));
    function watchBalance() {
        var coinbase = web3.eth.coinbase;
        var originalBalance = web3.eth.getBalance(coinbase).toNumber();
        document.getElementById(&#39;coinbase&#39;).innerText = &#39;coinbase: &#39; + coinbase;
        document.getElementById(&#39;original&#39;).innerText = &#39; original balance: &#39; + originalBalance + &#39;    watching...&#39;;
        web3.eth.filter(&#39;latest&#39;).watch(function() {
            var currentBalance = web3.eth.getBalance(coinbase).toNumber();
            document.getElementById(&amp;quot;current&amp;quot;).innerText = &#39;current: &#39; + currentBalance;
            document.getElementById(&amp;quot;diff&amp;quot;).innerText = &#39;diff:    &#39; + (currentBalance - originalBalance);
        });
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;coinbase balance&amp;lt;/h1&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick=&amp;quot;watchBalance();&amp;quot;&amp;gt;watch balance&amp;lt;/button&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;coinbase&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;original&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;current&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;diff&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&amp;hellip; It works, you can see the balance on the contract!&lt;/p&gt;

&lt;h2 id=&#34;let-s-greet-now&#34;&gt;Let&amp;rsquo;s greet now&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/bignumber.js/2.4.0/bignumber.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./web3-light.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        var Web3 = require(&#39;web3&#39;);
        var web3 = new Web3();
        web3.setProvider(new web3.providers.HttpProvider(&#39;http://localhost:9012&#39;));
        function watchBalance() {
            var coinbase = web3.eth.coinbase;
            var originalBalance = web3.eth.getBalance(coinbase).toNumber();
            document.getElementById(&#39;coinbase&#39;).innerText = &#39;coinbase: &#39; + coinbase;
            document.getElementById(&#39;original&#39;).innerText = &#39; original balance: &#39; + originalBalance + &#39;    watching...&#39;;
            web3.eth.filter(&#39;latest&#39;).watch(function() {
                var currentBalance = web3.eth.getBalance(coinbase).toNumber();
                document.getElementById(&amp;quot;current&amp;quot;).innerText = &#39;current: &#39; + currentBalance;
                document.getElementById(&amp;quot;diff&amp;quot;).innerText = &#39;diff:    &#39; + (currentBalance - originalBalance);
            });
        }
        function greet() {
            var contractAddress = &#39;0x5d3425ccedeae0eb36521c4cf93ec6544dbad9bd&#39;;
            var greeter = web3.eth.contract([{constant:false,inputs:[],name:&#39;kill&#39;,outputs:[],type:&#39;function&#39;},{constant:true,inputs:[],name:&#39;greet&#39;,outputs:[{name:&#39;&#39;,type:&#39;string&#39;}],type:&#39;function&#39;},{inputs:[{name:&#39;_greeting&#39;,type:&#39;string&#39;}],type:&#39;constructor&#39;}]).at(contractAddress);
            var greetings = greeter.greet();
            document.getElementById(&#39;greeting&#39;).innerText = greetings;
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;coinbase balance&amp;lt;/h1&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick=&amp;quot;watchBalance();&amp;quot;&amp;gt;watch balance&amp;lt;/button&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;coinbase&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;original&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;current&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;diff&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;h1&amp;gt;greetings&amp;lt;/h1&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick=&amp;quot;greet();&amp;quot;&amp;gt;greet!&amp;lt;/button&amp;gt;
    &amp;lt;div id=&amp;quot;greeting&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you have it! the dapp is responding!&lt;/p&gt;

&lt;p&gt;caveat: when you won&amp;rsquo;t be running a test, you will need to get an http provider connected to the live blockchain. You can be sure to have one if you run your own node, I&amp;rsquo;m not sure yet if there is any open htt provider node out there.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ethereum first smart contract</title>
      <link>https://vincentserpoul.github.io/post/ethereum-first-contract/</link>
      <pubDate>Wed, 03 Aug 2016 13:00:00 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-first-contract/</guid>
      <description>

&lt;h2 id=&#34;launch-your-geth-or-testrpc-private-instance&#34;&gt;Launch your geth (or testrpc) private instance&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./geth \
    --identity &amp;quot;gethTest&amp;quot; \
    --rpc --rpcport &amp;quot;9012&amp;quot; \
    --rpccorsdomain &amp;quot;YOUR_TEST_DOMAIN_APP_RUN_FROM&amp;quot; \
    --datadir &amp;quot;./testChain&amp;quot; \
    --port &amp;quot;30303&amp;quot; \
    --nodiscover \
    --rpcapi &amp;quot;db,eth,net,web3&amp;quot; \
    --networkid 1999 \
    --dev console
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;within-the-console-compile-your-contract&#34;&gt;Within the console, compile your contract&lt;/h2&gt;

&lt;p&gt;check this tutorial: &lt;a href=&#34;https://www.ethereum.org/greeter&#34;&gt;https://www.ethereum.org/greeter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I had an issue when I followed the contract tutorial, my contract would not be mined after I was trying to deploy it.&lt;/p&gt;

&lt;p&gt;The issue was that my account was locked :/ and the greeter contract stupidly silently fails&amp;hellip;
Here is the modified code to see the obvious error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var _greeting = &amp;quot;Hello World!&amp;quot;
var greeterContract = web3.eth.contract(greeterCompiled.greeter.info.abiDefinition);

var greeter = greeterContract.new(_greeting,{from:web3.eth.accounts[0], data: greeterCompiled.greeter.code, gas: 30000000}, function(e, contract){
    if(!e) {

      if(!contract.address) {
        console.log(&amp;quot;Contract transaction send: TransactionHash: &amp;quot; + contract.transactionHash + &amp;quot; waiting to be mined...&amp;quot;);

      } else {
        console.log(&amp;quot;Contract mined! Address: &amp;quot; + contract.address);
        console.log(contract);
      }

    } else {
        console.log(&amp;quot;error!&amp;quot;);
        console.log(e);
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which returns&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error!
Error: account is locked
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To unlock the account, simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;personal.unlockAccount(eth.accounts[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then encountered ANOTHER error!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error!
Error: Exceeds block gas limit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I simply decreased the gas to 3000000, and finally got:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I0803 15:14:29.423492 eth/api.go:1191] Tx(0x7584a963a9c2a21e623e607826ad47ae358d056ed159b82a21793d4541148e86) created: 0x5f3425ccedeae0eb36521c4cf93ec6544dbad9bd
Contract transaction send: TransactionHash: 0x7284a963a9c3a21e623e607826ad47ae358d056ed159b82a21793d4541148e86 waiting to be mined...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, simply mine it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;miner.start()
...
Contract mined! Address: 0x5d3125ccedeae0eb36521c4cf93ec6544dbad9bd
...
miner.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah, victory! my contract is deployed on my private ethereum node.&lt;/p&gt;

&lt;p&gt;Keep that address and also make sure to run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;greeterCompiled.greeter.info.abiDefinition
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in order to get the ABI that will be used later in javascript (Application Binary Interface)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{
    constant: false,
    inputs: [],
    name: &amp;quot;kill&amp;quot;,
    outputs: [],
    type: &amp;quot;function&amp;quot;
}, {
    constant: true,
    inputs: [],
    name: &amp;quot;greet&amp;quot;,
    outputs: [{
        name: &amp;quot;&amp;quot;,
        type: &amp;quot;string&amp;quot;
    }],
    type: &amp;quot;function&amp;quot;
}, {
    inputs: [{
        name: &amp;quot;_greeting&amp;quot;,
        type: &amp;quot;string&amp;quot;
    }],
    type: &amp;quot;constructor&amp;quot;
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;when-done-kill-it&#34;&gt;When done, kill it!&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;greeter.kill.sendTransaction({from:eth.accounts[0]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we will simply interact with the contract.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ethereum dev environment</title>
      <link>https://vincentserpoul.github.io/post/ethereum-dev-environment/</link>
      <pubDate>Mon, 01 Aug 2016 08:27:27 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-dev-environment/</guid>
      <description>

&lt;h2 id=&#34;part-1-setup-your-ethereum-node&#34;&gt;Part 1 - Setup your ethereum node&lt;/h2&gt;

&lt;p&gt;There are many ways you can setup a node to dev an Ethereum dapp.
You can use the live network: not advisable obviously for cost and speed reasons.
You can use the test network: not advisable for speed reasons.
You can use a testchain set up with Geth: easy but a bit tedious as you need to mine.
You can the ethereum testrpc: easiest!&lt;/p&gt;

&lt;p&gt;I will talk about the last two setup in this article.&lt;/p&gt;

&lt;h3 id=&#34;using-testrpc&#34;&gt;Using testrpc&lt;/h3&gt;

&lt;p&gt;Simply install through npm (if you want it globally available, add -g after install, as usual)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install ethereumjs-testrpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then run it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node_modules/ethereumjs-testrpc/bin/testrpc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;using-geth&#34;&gt;Using geth&lt;/h3&gt;

&lt;p&gt;Download geth latest release (&lt;a href=&#34;https://github.com/ethereum/go-ethereum/releases&#34;&gt;https://github.com/ethereum/go-ethereum/releases&lt;/a&gt;)
and extract it.&lt;/p&gt;

&lt;p&gt;Create a file customGenesis.json&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;nonce&amp;quot;: &amp;quot;0x0000000000000042&amp;quot;,
  &amp;quot;timestamp&amp;quot;: &amp;quot;0x0&amp;quot;,
  &amp;quot;parentHash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;extraData&amp;quot;: &amp;quot;0x0&amp;quot;,
  &amp;quot;gasLimit&amp;quot;: &amp;quot;0x8000000&amp;quot;,
  &amp;quot;difficulty&amp;quot;: &amp;quot;0x400&amp;quot;,
  &amp;quot;mixhash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
  &amp;quot;coinbase&amp;quot;: &amp;quot;0x3333333333333333333333333333333333333333&amp;quot;,
  &amp;quot;alloc&amp;quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then init yout node with the genesis block above&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;chmod +x geth
./geth init ./customGenesis.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;run-your-node-with-console-attached&#34;&gt;Run your node with console attached&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./geth \
    --identity &amp;quot;gethTest&amp;quot; \
    --rpc --rpcport &amp;quot;9012&amp;quot; \
    --rpccorsdomain &amp;quot;YOUR_TEST_DOMAIN_APP_RUN_FROM&amp;quot; \
    --datadir &amp;quot;./testChain&amp;quot; \
    --port &amp;quot;30303&amp;quot; \
    --nodiscover \
    --rpcapi &amp;quot;db,eth,net,web3&amp;quot; \
    --networkid 1999 \
    --dev console
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-a-base-account&#34;&gt;Create a base account&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.accounts
[]
&amp;gt; personal.newAccount()
Passphrase:
Repeat passphrase:
&amp;quot;0xedea6958c57fc0cd4bd63b3e7b395393dc76bfb6&amp;quot;
&amp;gt; eth.accounts
[&amp;quot;0xedea6958c57fc0cd4bd63b3e7b395393dc76bfb6&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mine-on-your-newly-created-account&#34;&gt;Mine on your newly created account&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;miner.setEtherbase(eth.accounts[0])
miner.start(8)
miner.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if the mining worked&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; eth.getBalance(eth.accounts[0]).toNumber();
55000000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the next posts, we will start talking about development of dapps.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>