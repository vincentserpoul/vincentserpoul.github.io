<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VS tech corner</title>
    <link>https://vincentserpoul.github.io/tags/dapp/index.xml</link>
    <description>Recent content on VS tech corner</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://vincentserpoul.github.io/tags/dapp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ethereum first dapp - part 3</title>
      <link>https://vincentserpoul.github.io/post/ethereum-first-dapp-part-3/</link>
      <pubDate>Fri, 12 Aug 2016 12:00:27 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-first-dapp-part-3/</guid>
      <description>

&lt;h2 id=&#34;setting-up-a-light-wallet&#34;&gt;setting up a light wallet&lt;/h2&gt;

&lt;p&gt;In order to have a setup close to what the DAPP would be, we will use (metamask) [&lt;a href=&#34;http://www.metamask.io&#34;&gt;http://www.metamask.io&lt;/a&gt;] as a light wallet (there are other choices).&lt;/p&gt;

&lt;p&gt;Metamask allows you to connect to a custom node.&lt;/p&gt;

&lt;p&gt;We will then connect to our node, &lt;a href=&#34;http://localhost:9012&#34;&gt;http://localhost:9012&lt;/a&gt;
If everthing is fine, metamasks should indicate it&amp;rsquo;s connected.&lt;/p&gt;

&lt;p&gt;Then, we can import the metamask account to our local node by simply specifying the datadir we have setup the node data.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s imagine metamask give us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xcddddd76a763de6e9ac19e7ec8f71ed77d61eebc0a93068fc9f2a544462db7d2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as the key.&lt;/p&gt;

&lt;p&gt;Then let&amp;rsquo;s just copy this, without thw 0x inside a separate file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;cddddd76a763de6e9ac19e7ec8f71ed77d61eebc0a93068fc9f2a544462db7d2&amp;quot; &amp;gt;&amp;gt; pvkey.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then import it in our local chain&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;geth --datadir &amp;quot;./testChain&amp;quot; account import ./pvkey.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if you look at the list of accounts in your local node, you should see now the newly imported account.&lt;/p&gt;

&lt;h2 id=&#34;give-me-ether&#34;&gt;give me ether!&lt;/h2&gt;

&lt;p&gt;Now, simply transfer some Ether to the newly imported account
In geth, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eth.sendTransaction({from: &#39;0xfffffff&#39;, to: &#39;0xddddddd&#39;, value: web3.toWei(1000, &amp;quot;ether&amp;quot;)})
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ethereum first dapp - part 2</title>
      <link>https://vincentserpoul.github.io/post/ethereum-first-dapp-part-2/</link>
      <pubDate>Wed, 10 Aug 2016 15:00:27 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-first-dapp-part-2/</guid>
      <description>

&lt;h1 id=&#34;frontend&#34;&gt;Frontend&lt;/h1&gt;

&lt;h2 id=&#34;prepare-your-folder-for-your-dapp&#34;&gt;Prepare your folder for your dapp&lt;/h2&gt;

&lt;p&gt;I will be using &lt;a href=&#34;https://github.com/mxstbr/react-boilerplate&#34;&gt;https://github.com/mxstbr/react-boilerplate&lt;/a&gt; as it&amp;rsquo;s quite nice and I&amp;rsquo;ve been playing with React for a bit now.&lt;/p&gt;

&lt;p&gt;I will not go into the details of setting this up, it&amp;rsquo;s a totally different topic.
If you are not familiar with it, it&amp;rsquo;s probably a waste of time for you to read.&lt;/p&gt;

&lt;h2 id=&#34;example-web3-component-with-react&#34;&gt;Example web3 component with React&lt;/h2&gt;

&lt;p&gt;This boilerplate uses immutable, redux and redux-sagas in order to deal with data.
We will use this to connect/dialog with our local node.&lt;/p&gt;

&lt;h3 id=&#34;actions&#34;&gt;Actions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const ETH_CONNECT = &#39;app/EthConnect/ETH_CONNECT&#39;;

export function ethConnect(web3Provider) {
  return {
    type: ETH_CONNECT,
    web3Provider,
  };
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reducers&#34;&gt;reducers&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/*
 *
 * EthConnect reducer
 *
 */

// eslint exception for web3
/* global web3:true */

import { fromJS } from &#39;immutable&#39;;
import Web3 from &#39;web3&#39;;
import { ETH_CONNECT } from &#39;./constants&#39;;

const initialState = fromJS({
  web3Connection: false,
});

function ethConnectReducer(state = initialState, action) {
  switch (action.type) {
    case ETH_CONNECT:
      return state
        .set(&#39;web3Connection&#39;, web3Connect(action.web3Provider));
    default:
      return state;
  }
}

const web3Connect = (web3Provider) =&amp;gt; {
  let web3Connection;

  // If mist or metamask or else is already injected there as a provider
  if (typeof web3 !== &#39;undefined&#39;) {
    web3Connection = new Web3(web3.currentProvider);
  } else {
    web3Connection = new Web3(new Web3.providers.HttpProvider(web3Provider));
  }

  if (web3Connection.isConnected()) {
    return web3Connection;
  }

  return false;
};


export default ethConnectReducer;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;selectors&#34;&gt;selectors&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;import { createSelector } from &#39;reselect&#39;;

/**
 * Direct selector to the ethConnect state domain
 */
const selectEthConnectDomain = () =&amp;gt; state =&amp;gt; state.get(&#39;ethConnect&#39;);

/**
 * Other specific selectors
 */


/**
 * Default selector used by EthConnect
 */

const selectEthConnect = () =&amp;gt; createSelector(
  selectEthConnectDomain(),
  (substate) =&amp;gt; substate.toJS(),
);

const selectEthConnectWeb3Connection = () =&amp;gt; createSelector(
  selectEthConnectDomain(),
  (substate) =&amp;gt; substate.get(&#39;web3Connection&#39;)
);

const selectEthConnectIsConnected = () =&amp;gt; createSelector(
  selectEthConnectDomain(),
  (substate) =&amp;gt; {
    if (substate.get(&#39;web3Connection&#39;) === false) {
      return false;
    }
    return true;
  }
);

export default selectEthConnect;
export {
  selectEthConnectDomain,
  selectEthConnectWeb3Connection,
  selectEthConnectIsConnected,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;component-itself&#34;&gt;component itself&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*
 *
 * EthConnect
 *
 */

import React from &#39;react&#39;;
import { connect } from &#39;react-redux&#39;;
import { createStructuredSelector } from &#39;reselect&#39;;
import { ethConnect } from &#39;./actions&#39;;
import { selectEthConnectIsConnected } from &#39;./selectors&#39;;
import ConnectionStatus from &#39;components/ConnectionStatus&#39;;

export class EthConnect extends React.Component { // eslint-disable-line react/prefer-stateless-function
  // That&#39;s when we connect, each time the component is mounted
  componentWillMount() {
    this.props.connect(this.props.web3Provider);
  }

  render() {
    return (
      &amp;lt;ConnectionStatus isConnected={this.props.isConnected} /&amp;gt;
    );
  }
}

EthConnect.propTypes = {
  loading: React.PropTypes.bool,
  web3Provider: React.PropTypes.string.isRequired,
  connect: React.PropTypes.func.isRequired,
  isConnected: React.PropTypes.bool,
};

const mapStateToProps = createStructuredSelector({
  isConnected: selectEthConnectIsConnected(),
});

function mapDispatchToProps(dispatch) {
  return {
    connect: (web3Provider) =&amp;gt; dispatch(ethConnect(web3Provider)),
    dispatch,
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(EthConnect);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there we go! Our app is up and running and connect to the local node.&lt;/p&gt;

&lt;p&gt;In the next step, we will see how to play with this app with more complex interactions, contract functions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ethereum first dapp - part 1</title>
      <link>https://vincentserpoul.github.io/post/ethereum-first-dapp-part-1/</link>
      <pubDate>Mon, 08 Aug 2016 15:00:27 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-first-dapp-part-1/</guid>
      <description>

&lt;h1 id=&#34;contracts&#34;&gt;Contracts&lt;/h1&gt;

&lt;h2 id=&#34;prepare-your-folder-for-your-dapp&#34;&gt;Prepare your folder for your dapp&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir dapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inside this folder, we&amp;rsquo;ll create one folder for truffle, one for geth.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd dapp
mkdir truffle geth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inside the geth folder, simply put the customGenesis block you can find in the ethereum-dev-environment blog post.&lt;/p&gt;

&lt;p&gt;We are going to use two Ethereum clients, one for tests and devs, testrpc and one for a more real interaction, geth.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s install truffle and testrpc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install ethereumjs-testrpc truffle
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;truffle&#34;&gt;Truffle&lt;/h2&gt;

&lt;p&gt;Truffle is a-m-a-z-i-n-g for contract development. It will allow you to unit test the contracts and compile them into usable javascript objects usable in web3! Just what we needed!&lt;/p&gt;

&lt;p&gt;First, init truffle scaffolding (I don&amp;rsquo;t like -g install XD, so bear with my node_modules folder).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node_modules/truffle/cli.js init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create different folders. You can have a look at &lt;a href=&#34;http://truffle.readthedocs.io/&#34;&gt;http://truffle.readthedocs.io/&lt;/a&gt; to have more details.&lt;/p&gt;

&lt;h2 id=&#34;testrpc&#34;&gt;Testrpc&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s launch the ethereumjs-testrpc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node_modules/ethereumjs-testrpc/bin/testrpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will see it will create a new chain, in memory and create 10 new accounts for you to test.&lt;/p&gt;

&lt;h2 id=&#34;standard-token-contracts&#34;&gt;Standard token contracts&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t try to reinvent the wheel, Consensys has given standard contracts to issue your own token.
Have a look here: &lt;a href=&#34;https://github.com/ConsenSys/Tokens&#34;&gt;https://github.com/ConsenSys/Tokens&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Just copy to your contract folder:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tokens/Token_Contracts/contracts/HumanStandardToken.sol&lt;/li&gt;
&lt;li&gt;Tokens/Token_Contracts/contracts/StandardToken.sol&lt;/li&gt;
&lt;li&gt;Tokens/Token_Contracts/contracts/Token.sol&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;migrate&#34;&gt;Migrate&lt;/h2&gt;

&lt;p&gt;Here is the simple migration script I used&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = (deployer) =&amp;gt; {
  deployer.deploy(
    HumanStandardToken,
        1000000,
        &#39;mold&#39;,
        &#39;0&#39;,
        &#39;M&#39;
  );
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to compile and deploy your contracts in the rpc node you configured in truffle.js, you need to launch the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node_modules/truffle/cli.js migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your code compiles, it will create javascript objects for each of your contract in the folder build/contracts.&lt;/p&gt;

&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;Here is an example of tests on HumanStandardToken (ES6)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const it = require(&#39;mocha&#39;).it;
const assert = require(&#39;chai&#39;).assert;

contract(&#39;HumanStandardToken&#39;, (accounts) =&amp;gt; {
  it(&#39;should put 1000000 molds in the first account&#39;, () =&amp;gt; {
    const molds = HumanStandardToken.deployed();
    const initSupply = 1000000;

    return molds.balanceOf(accounts[0])
      .then(balance =&amp;gt; assert.equal(
          balance.valueOf(), initSupply,
          `${initSupply} molds weren&#39;t in the first account`
        )
      );
  });

  it(&#39;should transfer molds to another user&#39;, () =&amp;gt; {
    const molds = HumanStandardToken.deployed();

    return molds.transfer(accounts[1], 100, { from: accounts[0], gas: 400000 })
      .then(
        () =&amp;gt; molds.balanceOf(accounts[1])
      )
      .then(balance =&amp;gt; assert.equal(
          balance.valueOf(), 100,
          `${accounts[1]} didn&#39;t was not transfered 100 molds but ${balance.valueOf()}`
        )
      );
  });

  it(&#39;should emit a transfer event when there is a transfer&#39;, (done) =&amp;gt; {
    const transferredAmt = 1;

    const transferWatcher = molds.Transfer({ fromBlock: &#39;latest&#39; },
      (error, results) =&amp;gt; {
        assert.equal(
          results.args._value.valueOf(), transferredAmt,
          `transfer event amount not equal to ${transferredAmt}`
        );
        transferWatcher.stopWatching();
        done();
      });

    // trigger the event
    molds.transfer(accounts[1], transferredAmt, { from: accounts[0], gas: 400000 });
  });  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** / ! \ **
I was stuck for hours because of the way contract functions can be called.
There are two types of actions on the Ethereum blockchain. Action which change the contract states (like transfer funds for example), and the one which don&amp;rsquo;t (like get balance, for example).
In truffle, you call the latter with a &amp;ldquo;call&amp;rdquo; on the contract object, whereas the former doesn&amp;rsquo;t need it&amp;hellip; Confusing, isn&amp;rsquo;t it?
I found out later that there are constant functions in solidity, which basically mean functions that don&amp;rsquo;t change the contract state. When you specify these functions in you contract definition as &amp;ldquo;constant&amp;rdquo;, then, truffle doesn&amp;rsquo;t need the call&amp;hellip; Problem solved, everything now looks uniform.&lt;/p&gt;

&lt;p&gt;Now you can try if everything works fine, launch testrpc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node_modules/ethereumjs-testrpc/bin/testrpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and open a new terminal and launch the tests&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node_modules/truffle/cli.js test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creation-of-the-contracts-on-a-private-geth-or-even-morden&#34;&gt;Creation of the contracts on a private geth or even morden&lt;/h2&gt;

&lt;p&gt;Modify your truffle.js to whichever node you want to migrate your contracts to.
Mine is local geth, listening on port 9012, so truffle.js will become&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  rpc: {
    host: &#39;localhost&#39;,
    port: 9012,
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then migrate&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;node_modules/truffle/cli.js migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voila! if everything is ok, truffle should have created your contracts and updated the built contracts with the right contract addresses in build/contracts.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s play with these contracts on geth! See you on part 2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interacting with an Ethereum smart contract</title>
      <link>https://vincentserpoul.github.io/post/ethereum-interacting-with-contracts/</link>
      <pubDate>Wed, 03 Aug 2016 20:00:00 +0800</pubDate>
      
      <guid>https://vincentserpoul.github.io/post/ethereum-interacting-with-contracts/</guid>
      <description>

&lt;h2 id=&#34;check-the-address-of-the-current-deployed-contract&#34;&gt;Check the address of the current deployed contract&lt;/h2&gt;

&lt;p&gt;Remember when you mined your contract, it told your its address.
Now, reuse it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eth.getCode(&amp;quot;0x5f3425ccedeae0eb36521c4cf93ec6544dbad9bd&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-the-contract-with-a-simple-interaction&#34;&gt;Test the contract with a simple interaction&lt;/h2&gt;

&lt;p&gt;get the latest web3-light.min.js js from &lt;a href=&#34;https://github.com/ethereum/web3.js/releases&#34;&gt;https://github.com/ethereum/web3.js/releases&lt;/a&gt; and simply copy the dist/web3-light.min.js into the same folder as the following HTML file.&lt;/p&gt;

&lt;p&gt;then, use this html to interact with your contract on the local node:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/bignumber.js/2.4.0/bignumber.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./web3-light.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    var Web3 = require(&#39;web3&#39;);
    var web3 = new Web3();
    web3.setProvider(new web3.providers.HttpProvider(&#39;http://localhost:9012&#39;));
    function watchBalance() {
        var coinbase = web3.eth.coinbase;
        var originalBalance = web3.eth.getBalance(coinbase).toNumber();
        document.getElementById(&#39;coinbase&#39;).innerText = &#39;coinbase: &#39; + coinbase;
        document.getElementById(&#39;original&#39;).innerText = &#39; original balance: &#39; + originalBalance + &#39;    watching...&#39;;
        web3.eth.filter(&#39;latest&#39;).watch(function() {
            var currentBalance = web3.eth.getBalance(coinbase).toNumber();
            document.getElementById(&amp;quot;current&amp;quot;).innerText = &#39;current: &#39; + currentBalance;
            document.getElementById(&amp;quot;diff&amp;quot;).innerText = &#39;diff:    &#39; + (currentBalance - originalBalance);
        });
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;coinbase balance&amp;lt;/h1&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick=&amp;quot;watchBalance();&amp;quot;&amp;gt;watch balance&amp;lt;/button&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;coinbase&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;original&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;current&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;diff&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&amp;hellip; It works, you can see the balance on the contract!&lt;/p&gt;

&lt;h2 id=&#34;let-s-greet-now&#34;&gt;Let&amp;rsquo;s greet now&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/bignumber.js/2.4.0/bignumber.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;./web3-light.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        var Web3 = require(&#39;web3&#39;);
        var web3 = new Web3();
        web3.setProvider(new web3.providers.HttpProvider(&#39;http://localhost:9012&#39;));
        function watchBalance() {
            var coinbase = web3.eth.coinbase;
            var originalBalance = web3.eth.getBalance(coinbase).toNumber();
            document.getElementById(&#39;coinbase&#39;).innerText = &#39;coinbase: &#39; + coinbase;
            document.getElementById(&#39;original&#39;).innerText = &#39; original balance: &#39; + originalBalance + &#39;    watching...&#39;;
            web3.eth.filter(&#39;latest&#39;).watch(function() {
                var currentBalance = web3.eth.getBalance(coinbase).toNumber();
                document.getElementById(&amp;quot;current&amp;quot;).innerText = &#39;current: &#39; + currentBalance;
                document.getElementById(&amp;quot;diff&amp;quot;).innerText = &#39;diff:    &#39; + (currentBalance - originalBalance);
            });
        }
        function greet() {
            var contractAddress = &#39;0x5d3425ccedeae0eb36521c4cf93ec6544dbad9bd&#39;;
            var greeter = web3.eth.contract([{constant:false,inputs:[],name:&#39;kill&#39;,outputs:[],type:&#39;function&#39;},{constant:true,inputs:[],name:&#39;greet&#39;,outputs:[{name:&#39;&#39;,type:&#39;string&#39;}],type:&#39;function&#39;},{inputs:[{name:&#39;_greeting&#39;,type:&#39;string&#39;}],type:&#39;constructor&#39;}]).at(contractAddress);
            var greetings = greeter.greet();
            document.getElementById(&#39;greeting&#39;).innerText = greetings;
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;coinbase balance&amp;lt;/h1&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick=&amp;quot;watchBalance();&amp;quot;&amp;gt;watch balance&amp;lt;/button&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;coinbase&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;original&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;current&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;diff&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;h1&amp;gt;greetings&amp;lt;/h1&amp;gt;
    &amp;lt;button type=&amp;quot;button&amp;quot; onClick=&amp;quot;greet();&amp;quot;&amp;gt;greet!&amp;lt;/button&amp;gt;
    &amp;lt;div id=&amp;quot;greeting&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you have it! the dapp is responding!&lt;/p&gt;

&lt;p&gt;caveat: when you won&amp;rsquo;t be running a test, you will need to get an http provider connected to the live blockchain. You can be sure to have one if you run your own node, I&amp;rsquo;m not sure yet if there is any open htt provider node out there.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>